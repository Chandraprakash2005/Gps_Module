<!DOCTYPE html>
<html>
<head>
  <title>Campus Navigation (Click to Select)</title>

  <link rel="stylesheet"
        href="https://unpkg.com/leaflet/dist/leaflet.css"/>

  <style>
    body { margin: 0; }
    #map { height: 100vh; width: 100%; }

    .control-box {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 6px;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }
  </style>
</head>

<body>

<div class="control-box">
  <b>Instructions</b><br>
  üñ•Ô∏è PC is source<br>
  üñ±Ô∏è Click on map to choose destination<br>
  <button onclick="calculateRoute()">Find Path</button>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
/* ================= MAP ================= */
const map = L.map("map").setView([12.7517, 80.1993], 16);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "¬© OpenStreetMap"
}).addTo(map);

/* ================= DYNAMIC PC SOURCE (GPS) ================= */
let PC_SOURCE = [80.19539, 12.75164]; // Default fallback
let sourceMarker = null;

// Get user's actual GPS location
if (navigator.geolocation) {
  navigator.geolocation.watchPosition(
    (position) => {
      const lng = position.coords.longitude;
      const lat = position.coords.latitude;
      
      PC_SOURCE = [lng, lat]; // Update source to actual GPS
      
      // Update marker
      if (sourceMarker) map.removeLayer(sourceMarker);
      
      sourceMarker = L.marker([lat, lng])
        .addTo(map)
        .bindPopup("üìç Your Location (Source)")
        .openPopup();
      
      console.log("üìç PC Location updated:", PC_SOURCE);
    },
    (error) => {
      console.warn("GPS unavailable, using default location:", error);
      // Show default marker
      sourceMarker = L.marker([PC_SOURCE[1], PC_SOURCE[0]])
        .addTo(map)
        .bindPopup("üñ•Ô∏è Default Location (Source)");
    },
    { enableHighAccuracy: true, maximumAge: 0, timeout: 15000 }
  );
} else {
  // GPS not supported, use default
  sourceMarker = L.marker([PC_SOURCE[1], PC_SOURCE[0]])
    .addTo(map)
    .bindPopup("üñ•Ô∏è Default Location (Source)");
}

/* ================= CLICKED DESTINATION ================= */
let destination = null;
let destMarker = null;
let routeLayer = null;

/* ================= MAP CLICK HANDLER ================= */
map.on("click", function (e) {
  const lat = e.latlng.lat;
  const lng = e.latlng.lng;

  destination = [lng, lat]; // [lng, lat]

  if (destMarker) map.removeLayer(destMarker);

  destMarker = L.marker([lat, lng])
    .addTo(map)
    .bindPopup("üéØ Selected Destination")
    .openPopup();

  // Auto-calculate route
  calculateRoute();
});

/* ================= ROUTING ================= */
async function calculateRoute() {

  if (!destination) {
    alert("Click on the map to select a destination");
    return;
  }

  const response = await fetch("/route", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      coordinates: [PC_SOURCE, destination]
    })
  });

  const data = await response.json();

  if (!data.features) {
    console.error("Routing error:", data);
    alert("Route not found. Try clicking nearer to a path.");
    return;
  }

  const coords = data.features[0].geometry.coordinates;
  const latLngs = coords.map(c => [c[1], c[0]]);

  // Display coordinates in console
  console.log("=== ROUTE COORDINATES ===");
  console.log("Total waypoints:", coords.length);
  console.log("All coordinates [lng, lat]:", coords);
  console.log("Distance:", data.features[0].properties.distance, "meters");
  console.log("Duration:", data.features[0].properties.duration, "seconds");

  // Process route to generate commands
  const commands = generateMovementCommands(coords);
  console.log("=== MOVEMENT COMMANDS ===");
  console.log(commands);

  // Send to Raspberry Pi
  sendToPi(coords, data.features[0].properties.distance, data.features[0].properties.duration, commands);

  if (routeLayer) map.removeLayer(routeLayer);

  routeLayer = L.polyline(latLngs, {
    color: "blue",
    weight: 6
  }).addTo(map);

  map.fitBounds(routeLayer.getBounds());
}

/* ================= SEND TO RASPBERRY PI ================= */
async function sendToPi(routeCoords, distance, duration, commands) {
  try {
    const response = await fetch("http://10.177.21.229:5000/route", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        coordinates: routeCoords,   // [[lng,lat], [lng,lat], ...]
        distance: distance,
        duration: duration,
        commands: commands          // ["mf", "tf30", "mf", ...]
      })
    });

    const data = await response.json();
    console.log("‚úÖ Sent to Pi:", data);

  } catch (err) {
    console.error("‚ùå Failed to send to Pi:", err);
  }
}

/* ================= MOVEMENT LOGIC ================= */

// Calculate distance between two points in meters (Haversine)
function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3; // Earth Radius in meters
  const œÜ1 = lat1 * Math.PI / 180;
  const œÜ2 = lat2 * Math.PI / 180;
  const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
  const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
            Math.cos(œÜ1) * Math.cos(œÜ2) *
            Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c;
}

// Calculate bearing between two points in degrees
function getBearing(lat1, lon1, lat2, lon2) {
  const y = Math.sin((lon2 - lon1) * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180);
  const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
            Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos((lon2 - lon1) * Math.PI / 180);
  let brng = Math.atan2(y, x) * 180 / Math.PI;
  return (brng + 360) % 360;
}

function generateMovementCommands(coords) {
  if (coords.length < 2) return [];

  const commands = [];
  let currentSegmentBearing = null;
  let accumulatedDistance = 0;
  let isMovingBackward = false;

  // Helper to format absolute bearing as tr/tl
  function formatAbsoluteTurn(bearing) {
    bearing = (bearing + 360) % 360; 
    if (bearing <= 180) {
      return `tr${Math.round(bearing)}`;
    } else {
      return `tl${Math.round(360 - bearing)}`;
    }
  }

  // Helper to push accumulated movement
  function flushMovement() {
    if (accumulatedDistance > 0.5) {
      const type = isMovingBackward ? "mb" : "mf";
      commands.push(`${type}${accumulatedDistance.toFixed(1)}`);
      accumulatedDistance = 0;
    }
  }

  for (let i = 0; i < coords.length - 1; i++) {
    const p1 = coords[i];     // [lng, lat]
    const p2 = coords[i + 1]; // [lng, lat]

    const dist = getDistance(p1[1], p1[0], p2[1], p2[0]);
    let bearing = getBearing(p1[1], p1[0], p2[1], p2[0]);

    if (currentSegmentBearing === null) {
      commands.push(formatAbsoluteTurn(bearing));
      currentSegmentBearing = bearing;
    } else {
      // Calculate diff relative to our face (currentSegmentBearing)
      let diff = bearing - currentSegmentBearing;
      if (diff > 180) diff -= 360;
      if (diff < -180) diff += 360;

      // Check if we should switch to mf/mb or turn
      if (Math.abs(diff) > 10) {
        // If the waypoint is behind us (~180 deg diff)
        if (Math.abs(diff) > 165 && Math.abs(diff) < 195) {
          flushMovement();
          isMovingBackward = !isMovingBackward;
          // Note: currentSegmentBearing doesn't change, we just flip direction
        } else {
          // Significant turn required
          flushMovement();
          isMovingBackward = false;
          commands.push(formatAbsoluteTurn(bearing));
          currentSegmentBearing = bearing;
        }
      }
    }
    
    accumulatedDistance += dist;
  }

  flushMovement();
  return commands;
}
  </script>

</body>
</html>
